### 처음부터 2장 실수 앞까지
##### 비트
디지털 정보의 단위
- 1nibble = 4bit
- 1byte = 8bit
- 1byte = 1문자(character)
- 영어는 1byte로 1문자 표현, 한글은 2byte가 필요
- 1워드: 특정 CPU에서 취급하는 명령어나 데이터의 길이에 해당하는 비트 수
	워드: 한 번에 의미 이는 단어를 주고 받을 때 필요한 데이터 크기
- 워드 길이는 8·16·32·64비트등 8의 배수가 가능하다

**MSB**
	가장 중요한 비트 (최상위 비트)
**LSB**
	가장 더 중요한 비트 (최하위 비트)

##### 진수 변환법
**2->10**
	 자릿수만큼 지수를 더해준다 
	 ex) 2진수의 100자릿수이면 2^2 이다.

**10->2**
	정수부분: 2로 나눈 나머지 / 소수부분 2로 곱한 정수부분

**2->8, 2->16**
	2->10, 끊어서 각각 8, 16 진법으로 전환

**16진수(hexa code) 암기**

##### 정수 표현
signed , unsigned 사람이 보게되는 언어에서 음수를 표현해주는가 아닌가.
컴퓨터의 수 체계는 이어져있다. 유한 개의 수가 존재. **(2장 17페이지 필수 숙지)**
###### 보수

**보수 표현 방식**
	**부호와 절댓값**: MSB(최상위 비트)를 부호로 사용한다. 양수:0, 음수:1
	**1의 보수 방식**, **2의 보수 방식**. 컴퓨터에서는 2의 보수 방식 활용.

**부호 확장**
1. 최상위 비트(부호 비트)를 비어 있는 왼쪽 부분에 채우고,

2. 원래의 비트 값은 오른쪽 부분에 그대로 복사하는 것이다.

(예시) 8 bit → 16 bit

	+2 : 00000010 → 0000000000000010

	-2 : 11111110 → 11111111111111110

### 2장 실수형부터

**2장 34 노랑이 주의깊게 보도록**

##### 디지털 코드

**그레이코드**
	비트가 변경될 때 비트가 한비트씩 변경됨
XOR의 진리표 (두 비트가 같으면 0 다르면 1)

아스키코드 3 4 6
#### 에러 검출 코드 (시험 X)

패리티 비트
	에러 검출용 비트(짝수 홀수 확인을 통해)



### 3장

###### 게이트
NOT 게이트 : 논리 부정 
	**7페이지** 논리표 진리표 부울대수식 외우기


조합 논리 회로

###### 가산기 : 더하는 조합 논리 회로
반가산기 
	2진수 2개를 입력하여 더해 S(Sum), C(Carry)로 출력하는 조합 논리 회로
전가산기
	2진수 2개와 아랫자리에서 올라온 C(Carry)를 포함해서 1자리 2진수 3개를 더해 출력하는 논리 회로

###### 감산기 : 뻬는 조합 논리 회로
반감산기
	2진수 2개를 입력하여 빼서 D , K(빌림수)로 출력하는 조합 논리 회로
전감산기
	2진수 2개와 빌림수K를 포함해 뺴서 D, K를 출력하는 조합 논리 회로 


### 4장
###### 컴퓨터의 기본 구조와 프로세서
**컴퓨터의 3가지 핵심장치**
	프로세서(Processor,CPU), 메모리, 입출력장치

**버스(Bus)**:장치간에 주소, 데이터, 제어신호를 전송하기 위한 연결 통로(연결선)
- 각각의 메모리에 접근하기 위해 1대1로 전선을 대응 시키는 대신에 디코더를 이용해 메모리에 접근

**프로세서 3가지 구성요소**
	- 산술논리연산장치(Arithmetic Logic Unit, ALU) : 산술 및 논리연산등 기본연산을 수행
	- 제어장치(Control Unit, CU): 메모리에서 명령어를 가져와 해독하고 실행에 필요한 장치들을 제어하는 신호를 발생
	- 레지스터세트(register set) : 프로세서내에 존재하는 용량은 작지만 매우 빠른 메모리, ALU의 연산과 관련된 데이터를 일시저장하거나 특정 제어 정보 저장
	

| 구성 요소                       | 역할                                                                    | 비유       |
| :-------------------------- | :-------------------------------------------------------------------- | :------- |
| CU (Control Unit)           | 명령어를 가져오고(Fetch), 해석(Decode)하고, 각 부품에 제어 신호를 보내는 역할.                  | 지휘자      |
| ALU (Arithmetic Logic Unit) | 산술 연산(+, -, *, /)과 논리 연산(AND, OR, NOT, 비교 등)을 수행.                     | 계산기, 논리왕 |
| 레지스터 (Register)             | CPU 내부의 초고속 임시 저장소. 데이터, 주소, 명령어를 잠깐 저장. (예: PC, IR, MAR, MDR, ACC 등) | 초고속 메모장  |

| 레지스터                          | 풀네임          | 역할                              | 비유             |
| :---------------------------- | :----------- | :------------------------------ | :------------- |
| PC (Program Counter)          | 프로그램 카운터     | 다음에 실행할 명령어의 메모리 주소를 저장         | 다음 할 일 적은 포스트잇 |
| IR (Instruction Register)     | 명령어 레지스터     | 현재 실행 중인 명령어를 저장                | 지금 읽고 있는 지시사항  |
| MAR (Memory Address Register) | 메모리 주소 레지스터  | 메모리의 어느 주소를 접근할지 저장             | 지도에 표시한 목적지    |
| MDR (Memory Data Register)    | 메모리 데이터 레지스터 | 메모리에서 읽어온 데이터 또는 메모리에 쓸 데이터를 저장 | 가방 안에 담긴 짐     |
| ACC (Accumulator)             | 어큐뮬레이터       | ALU 연산 결과를 임시 저장                | 계산기의 화면        |


1. **Instruction Fetch (IF)**
    
    ➤ PC가 가리키는 주소의 명령어를 **메모리(MEM)**에서 **IR**로 가져옴
    
2. **Instruction Decode (ID)**
    
    ➤ CU가 IR에 있는 명령어를 해석
    
3. **Operand Fetch (OF)** _(필요 시)_
    
    ➤ 연산에 필요한 데이터를 **메모리나 레지스터**에서 가져옴
    
4. **Execute (EX)**
    
    ➤ **ALU**에서 연산을 수행
    
5. **Write Back (WB)**
    
    ➤ 연산 결과를 **레지스터나 메모리**에 저장
    
6. **PC Update**
    
    ➤ 다음 명령어 주소로 **PC**를 갱신


# **컴퓨터구조 4장 요약 (김현석 교수님 자료 기반)**

  

## **1. 컴퓨터 구조 기본 개념**

### **폰 노이만 구조**

- 프로그램과 데이터를 동일한 메모리에 저장하는 구조
    
- 프로그램 저장, 인출, 실행이 순차적으로 이루어짐
    

  ### **컴퓨터 구성 요소**

- **CPU (Processor)**: 명령어 해석 및 실행
    
- **메모리 (Memory)**: 명령어와 데이터를 저장
    
- **입출력 장치 (I/O Device)**: 외부와의 데이터 교환 담당
    

### **버스 (Bus)**

- 장치 간의 데이터, 주소, 제어 신호 전달 경로
    
- **주소 버스(Address Bus)**: 메모리 주소 전달
    
- **데이터 버스(Data Bus)**: 데이터 전달
    
- **제어 버스(Control Bus)**: 제어 신호 전달
    
## **2. CPU 구성 요소**

### **주요 구성 요소**

- **ALU (Arithmetic Logic Unit)**: 산술, 논리 연산 수행
    
- **CU (Control Unit)**: 명령어 해석 및 제어 신호 생성
    
- **레지스터 (Register Set)**: 빠른 데이터 저장 장치
    
    - 범용 레지스터: 연산에 직접 사용
        
    - 특수 레지스터: AC, PC, IR 등
        
    
- 기타 구성: 온칩 캐시, 비디오 컨트롤러, FPU 등
    

## **3. 명령어 실행 사이클 (Instruction Cycle)**

1. **Fetch**: 명령어를 메모리에서 IR로 가져옴
    
2. **Decode**: 명령어 해석 및 실행 준비
    
3. **Execute**: 명령 실행 (연산 등)
    
4. **Write Back**: 결과를 저장
    

> 일반적으로 Fetch → Decode → Execute → Write Back의 순서로 반복 수행됨

## **4. 산술 논리 연산 장치 (ALU)**

### **산술 연산**

- 덧셈(Add), 뺄셈(Sub), 곱셈(Mul), 나눗셈(Div)
    
- 증가(Inc), 감소(Dec), 보수(Neg)
    
### **논리 연산**

- AND, OR, NOT, XOR
    
- Shift (시프트), Rotate (회전)
    

  ### **Booth 알고리즘**

- 이진 곱셈 시 덧셈 횟수를 줄여 연산 속도 향상
    

 ## **5. 레지스터 종류와 기능**

| **레지스터**                      | **역할**                   |
| ----------------------------- | ------------------------ |
| AC (Accumulator)              | 연산 결과 저장 및 중간 값 보관       |
| PC (Program Counter)          | 다음에 실행할 명령어 주소 저장        |
| IR (Instruction Register)     | 현재 실행 중인 명령어 저장          |
| SP (Stack Pointer)            | 스택의 Top 위치 추적            |
| FR (Flag Register)            | 상태 비트 저장 (Zero, Carry 등) |
| MAR (Memory Address Register) | 접근할 메모리 주소 저장            |
| MBR (Memory Buffer Register)  | 메모리에서 읽거나 쓸 데이터 임시 저장    |



## **6. 명령어 형식과 주소 지정 방식**

### **명령어 형식**

- **0주소 명령어**: 스택 기반 (ex. PUSH, POP)
    
- **1주소 명령어**: 오퍼랜드 하나 명시, AC 사용 (ex. ADD X)
    
- **2주소 명령어**: 두 개 오퍼랜드 중 하나는 결과 저장 (ex. ADD R1, R2)
    
- **3주소 명령어**: 두 입력, 하나의 출력 모두 별도 지정 (ex. ADD R1, R2, R3)
    

### **주소 지정 방식**

- **Immediate**: 명령어에 직접 값 포함
    
- **Direct**: 메모리 주소를 직접 명시
    
- **Register**: 오퍼랜드가 레지스터에 있음
    
- **Register Indirect**: 레지스터가 가리키는 주소에 데이터
    
- **Displacement**: 기준 주소 + 오프셋
    
- **Indexed**: 인덱스 레지스터와 상수 조합
    
- **Relative**: PC 기준 상대 주소
    
- **Base**: 세그먼트 레지스터 기준 주소
    
- **Implied**: 명시된 오퍼랜드 없음 (ex. RET)
    

 ## **7. 주요 명령어 그룹**

- **데이터 이동 명령**: LOAD, STORE, MOVE
    
- **산술/논리 연산**: ADD, SUB, AND, OR, XOR, NOT, SHIFT
    
- **조건 분기**: 조건에 따라 프로그램 흐름 변경 (ex. JUMP IF NEGATIVE)
    
- **프로시저 호출**: CALL, RET 등 (재귀 함수 지원 가능)
    
- **루프 제어**: 반복 횟수 제어 (ex. FOR, WHILE)
    
- **입출력 명령어**: Polling, Interrupt, DMA 기반 방식 지원
    


 ## **8. 인터럽트**

### **인터럽트 종류**

- **외부 인터럽트**: I/O 장치 신호
    
- **내부 인터럽트**: 예외 상황 (ex. Divide by zero)
    
- **소프트웨어 인터럽트**: 명령어로 생성 (ex. INT 3)
    

### **인터럽트 처리**

- 인터럽트 요청 → 현재 작업 저장 → 인터럽트 서비스 루틴 실행 → 원래 위치 복귀
    

### **DMA (Direct Memory Access)**

- CPU 개입 없이 메모리와 I/O 간 데이터 전송
    
- 사이클 스틸링 기법 사용 (CPU가 버스를 잠시 양보)
    

## **9. CISC vs RISC**

|**항목**|**CISC**|**RISC**|
|---|---|---|
|명령어 수|많음 (복잡)|적음 (단순)|
|명령어 길이|가변|고정|
|실행 속도|느림 (복잡한 명령)|빠름 (간단한 명령)|
|사용 예시|인텔 x86|ARM, MIPS|

- 현대 CPU는 복잡한 명령어를 단순한 RISC 명령어로 변환 후 실행 (하이브리드 구조)
    

  

## **10. 설계 원칙**

- 명령어는 하드웨어에서 직접 실행 가능해야 함
    
- 메모리는 읽기/쓰기만 참조
    
- 많은 레지스터 제공
    
- 명령어 해석은 간단해야 함
    
