
재귀: 크기가 큰 문제를 작게 나누어 여러변 실행하여 해결

기저조건 : 문제를 더이상 나눌 수 없는 조건


  

이진? 순차?

1. 2의 10승은 1024로 약 100회이다.
2. 정렬이 빠르게 O(N logN)의 속도로 됐다고 하더라도 개수가 적다면 순차가 유리할 수도 있다.
3. 정렬에 O(N logN) 탐색에 (logN) 이므로 시간복잡도는 O(N^2)가 아니다.
4. 이진탐색은 무조건 정렬되어있어야 한다.
5. mid 값으로 가는 것만 해도 O(N)이 소요 된다

헛발질
코드를 살펴보면 타겟을 찾거나 더이상 미드를 설정할 수 없을 때까지 작동한 뒤 count를 반환한다.
Case 1은 타겟이 없기에 3번 Case 2도 타겟이 없으니 3번 소요된다

잘못된 코드
left에 mid를 반환하는데 left right의 평균이 left가 나온다면 계속해서 반복된다. 

빠르게 값 찾기
첫 loop 0, 10 mid 4번째 인덱스이고 값은 19이다. 타겟보다 작으니 5번째 인덱스를 반환 
두번째 루프 5, 9  mid는 7이 되고 값이 24로 타겟보다 작으니 8을 반환한다 즉 답은 mid 7 left 8 right 9
하한과 상한
Case 1 첫 16 = 7 16 초과 = 8
Case 2 타겟 없으니 20 이상 5 20 초과 5
Case 3 첫 24 = 7 24 초과 9

bound 코드
코드를 살펴보면 bound1은 이상이 되는 첫값 bound2는 초과되는 첫값 bound2는 이하가 되는 마지막 값 bound4는 미만이 되는 마지막 값이다 측 타겟 16은 5 ~ 7 이고 이상은 5, 초과 8, 이하 7, 미만 4

upper bound
1. 초과가 없을 경우를 대비해서 배열 값을 값 arr.size
2. right = mid - 1을 보았을 때 target이 더 작음 arr[mid] > target
3. 초과값을 찾았으므로 갱신해야하니 mid
4. 모든 값을 봤을 때 마지막으로 갱신된 min_idx반환

의문의 메서드
1. 10 => 10,20 => 10 size()를 통해 1을 출력
2. 20 출력을 위해 D.back() (pop을 할경우 아래의 (20을 출력하지 못함)
3. 20, 17, 25, 13인 상황에서 13을 pop_back()하면서 출력(back()을 할시에 size가 2보다 커져서 마지막 2를 출력 불가) 20, 17, 25
4. 20, 17, 25에서 pop_front()를 통해 20을 출력 (front()함수가 보기에 없기 때문에 20을 출력할 유일한 방법)
5. 17, 25 에서 size()를 통해 2를 출력